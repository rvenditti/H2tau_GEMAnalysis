#define VHAnalyser_Jan13_cxx
#include "VHAnalyser_Jan13.h"
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <vector>
#include <string>
#include <algorithm>
#include <iostream>
#include <TLorentzVector.h>
#include <TMath.h>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <sstream>
using namespace std;

TFile* f_puweights;
TH1D* puweights;

static float puweight(float npu) {
    if (npu<0) return 1.0;
    return puweights->GetBinContent(puweights->FindBin(npu));
}


void VHAnalyser_Jan13::Loop()
{

   if (fChain == 0) return;
   
    //reweighting pileup
    //f_puweights = TFile::Open("/lustre/cms/store/user/rvenditti/reweightFunctionFall11.root", "read");
    f_puweights = TFile::Open("/lustre/cms/store/user/rvenditti/reweightFunctionFall12.root", "read");
    puweights = (TH1D*)f_puweights->Get("plot_data_div_MC");
    
   Long64_t nentries = fChain->GetEntriesFast();
   
    Int_t loose=0;
    /////////////////CICLO SU TUTTI GLI EVENTI
   Long64_t nbytes = 0, nb = 0;
   for (Long64_t jentry=0; jentry<nentries;jentry++) {
      Long64_t ientry = LoadTree(jentry);
      if (ientry < 0) break;
      nb = fChain->GetEntry(jentry);   nbytes += nb;
      // if (Cut(ientry) < 0) continue;
       Int_t event_type = 0;
       Int_t muon_type = 0;
       Int_t tau_type = 0;
       Int_t rigaMotherW=-2;
       Int_t rigaMotherH=-2;
       bool WplusGOODmuon=false;
       tagli[0]->Fill(1);
       
       /////////////////////////////////////////////////////////////
       for (unsigned int i = 0; i < trueNInt->size(); ++i) {
	 if ((*bunchCrossing)[i] == 0) {
	   //cout << " nPU = " << (*nPU)[i] << " bunchCrossing = " << (*bunchCrossing)[i] << endl;
	   hNPU->Fill((*trueNInt)[i]);
	 }
       }
        
       //pileup
       /*double NPU = (*nPU)[0];
        cout << " nPU_0 = " << NPU << endl;*/
       double NPU_1 = (*trueNInt)[0];  //corrisponde al BX=0
       //cout << " nPU_1 = " << NPU_1 << endl;
      	float puWeight = puweight(NPU_1);
	// float puWeight =1;
       //float puWeight = 1;
       //cout << " puWeight = " << puWeight << endl;
       
        for (unsigned int i = 0; i < trueNInt->size(); ++i) {
	  if ((*bunchCrossing)[i] == 0) {
	    //cout << " nPU = " << (*nPU)[i] << " bunchCrossing = " << (*bunchCrossing)[i] << endl;
	    hNPU_PU->Fill((*trueNInt)[i],puWeight);}
	}
       
       /////////////////////////////////////////////facciamo il filtro////////////////////////////////////////
              
       // NO GEN PARTICLE!!
       
        /*for(Int_t r=0; r<nGenParticle; r++){
           if(GenParticle_pdgId[r] == 25 && GenParticle_status[r] == 3 ){
               H_tot->Fill(1);
               rigaMotherH=r;}  // fine if GenParticle = H
           if(TMath::Abs(GenParticle_pdgId[r]) == 13 && GenParticle_status[r] == 1){
               muon_type=1;}
           if(TMath::Abs(GenParticle_pdgId[r]) == 15 && GenParticle_status[r] == 3 && GenParticle_motherIndex[r] == rigaMotherH){
               if(TMath::Abs(GenParticle_pdgId[r+1]) == 15 && GenParticle_status[r+1] == 3 && GenParticle_motherIndex[r+1] == rigaMotherH){
                   tau_type=1;}}
       }  // fine for GenParticle
       
       ////////////////////////////SELEZIONE DI W Z o tt
       for(Int_t r=0; r<nGenParticle; r++){
           if(TMath::Abs(GenParticle_pdgId[r]) == 24 && GenParticle_status[r] == 3 ){
               event_type = 1;
               rigaMotherW=r;
               break;}  // fine if GenParticle = W
           if(GenParticle_pdgId[r] == 23 && GenParticle_status[r] == 3 ){
               event_type = 2;
               break;}  // fine if GenParticle = Z
           if(TMath::Abs(GenParticle_pdgId[r]) == 6 && GenParticle_status[r] == 3 ){
               event_type = 3;
               break;}  // fine if GenParticle = t
       }  //fine for GenParticle
       
       if (event_type == 1) {W_tot->Fill(1);}
       if (event_type == 2) {Z_tot->Fill(1);}
       if (event_type == 3) {t_tot->Fill(1);}
       if (muon_type == 1) {muonStatus1->Fill(1);}
       if (tau_type == 1) {tautauEvent->Fill(1);}
       if (event_type == 1 && muon_type == 1){
           WplusGOODmuon=true;
           WplusMuon->Fill(1);}
       
       
       // DA ATTIVARE SOLO QUANDO GIRO SU WH!!
       if (event_type != 1) continue;
       // DA ATTIVARE SOLO QUANDO GIRO SU ZH!!
       // if (event_type != 2) continue;
       // DA ATTIVARE SOLO QUANDO GIRO SU ttH!!
       //if (event_type != 3) continue;
       
       ////////////////////////////////SE HO UN W ED UN MU STATUS1 VEDO SE QUESTO VIENE DAL W...ASSEGNO goodTrigger V SE ACCADE
       bool goodTrigger=false;
       Int_t rigaMu=-2;
       TLorentzVector muGen;
       muGen.SetPtEtaPhiM(1,0,0,0);
       
       if(WplusGOODmuon){
           for(Int_t r=0; r<nGenParticle; r++){
               if (TMath::Abs(GenParticle_pdgId[r]) == 13 && GenParticle_status[r] == 3 && GenParticle_motherIndex[r] == rigaMotherW){
                   rigaMotherW=r;
                   muonWstatus3->Fill(1);
               }
               
               if(TMath::Abs(GenParticle_pdgId[r]) == 13 && GenParticle_status[r] == 2 && GenParticle_motherIndex[r] == rigaMotherW){rigaMotherW=r;}
               if(TMath::Abs(GenParticle_pdgId[r]) == 13 && GenParticle_status[r] == 1 && GenParticle_motherIndex[r] == rigaMotherW){
                   //    std::cout<<"++++++++++++++++++++++++++++++++++evento W->mu: "<< jentry<<std::endl;
                   //TLorentzVector muGen;
                   muonW->Fill(1);
                   rigaMu=r;
                   goodTrigger=true;  //DA ATTIVARE!!!
                   muGen.SetPtEtaPhiE(GenParticle_pt[rigaMu], GenParticle_eta[rigaMu], GenParticle_phi[rigaMu], GenParticle_energy[rigaMu]);
                   //  std::cout<<" evento "<<jentry<<" muon gen pt "<<muGen.Pt()<<" muon gen eta  "<<muGen.Eta()<<" muon gen phi  "<<muGen.Phi()<<" muon gen en  "<<muGen.E()<<std::endl;
               }
           }//end for gen part
       }// end if mu status 1 plus W nell'evento
       
       ////////////////////////////////VEDO IL CANALE DI DECADIMANTO DEI TAU DA H
       bool Tau1jet=false;
       bool Tau2jet=false;
       bool Tau1electron=false;
       bool Tau2electron=false;
       bool Tau1muon=false;
       bool Tau2muon=false;
       bool FHevent=false;
       bool elejet=false;
       bool mujet=false;
       bool FLevent=false;
       bool GTFHevent=false;
       bool GTelejet=false;
       bool GTmujet=false;
       bool GTFLevent=false;
       TLorentzVector tau1Gen;
       TLorentzVector tau2Gen;
       tau1Gen.SetPtEtaPhiM(1,0,0,0);
       tau2Gen.SetPtEtaPhiM(1,0,0,0);
       TLorentzVector MHGen = tau1Gen + tau2Gen;
       if(tau_type==1){
           Int_t rigaTau1=-2, tau1_rigaprova=-2, tau1_rigaCorretta=-2;
           Int_t rigaTau2=-2, tau2_rigaprova=-2, tau2_rigaCorretta=-2;
           
           for(Int_t r=0; r<nGenParticle; r++){
               
               if(TMath::Abs(GenParticle_pdgId[r]) == 15 && GenParticle_status[r] == 3 && GenParticle_motherIndex[r] == rigaMotherH){
                   if(TMath::Abs(GenParticle_pdgId[r+1]) == 15 && GenParticle_status[r+1] == 3 && GenParticle_motherIndex[r+1] == rigaMotherH){
                       controlloTauTau->Fill(1);
                       rigaTau1=r;
                       rigaTau2=r+1;}}
               
               if(TMath::Abs(GenParticle_pdgId[r]) == 15 && GenParticle_status[r] == 2 && GenParticle_motherIndex[r] == rigaTau1){
                   if(TMath::Abs(GenParticle_pdgId[r+1]) == 15 && GenParticle_status[r+1] == 2 && GenParticle_motherIndex[r+1] == rigaTau2){
                       rigaTau1=r;
                       rigaTau2=r+1;}
                   /// ORDINO PER PT
                   tau1_rigaprova = rigaTau1;
                   tau2_rigaprova = rigaTau2;
                   if (GenParticle_pt[tau1_rigaprova] > GenParticle_pt[tau2_rigaprova]){
                       tau1_rigaCorretta = tau1_rigaprova;
                       tau2_rigaCorretta = tau2_rigaprova;                     }
                   else{tau1_rigaCorretta = tau2_rigaprova;
                       tau2_rigaCorretta = tau1_rigaprova;}
                   tau1Gen.SetPtEtaPhiE(GenParticle_pt[tau1_rigaCorretta], GenParticle_eta[tau1_rigaCorretta], GenParticle_phi[tau1_rigaCorretta], GenParticle_energy[tau1_rigaCorretta]);
                   tau2Gen.SetPtEtaPhiE(GenParticle_pt[tau2_rigaCorretta], GenParticle_eta[tau2_rigaCorretta], GenParticle_phi[tau2_rigaCorretta], GenParticle_energy[tau2_rigaCorretta]);
                   // chargeTauTau = Tau_charge[tau1_index]+Tau_charge[tau2_index];
                   MHGen = tau1Gen + tau2Gen;
                   // std::cout<<" evento "<<jentry<<" tau1 gen pt "<<tau1Gen.Pt()<<" tau1 gen eta  "<<tau1Gen.Eta()<<" tau1 gen phi  "<<tau1Gen.Phi()<<" tau1 gen en  "<<tau1Gen.E()<<std::endl;
                   //std::cout<<" evento "<<jentry<<" tau2 gen pt "<<tau2Gen.Pt()<<" tau2 gen eta  "<<tau2Gen.Eta()<<" tau2 gen phi  "<<tau2Gen.Phi()<<" tau2 gen en  "<<tau2Gen.E()<<std::endl;
               }
               
               if (TMath::Abs(GenParticle_pdgId[r]) >22 && GenParticle_motherIndex[r] == rigaTau1){Tau1jet=true;}
               if (TMath::Abs(GenParticle_pdgId[r]) == 11 && GenParticle_motherIndex[r] == rigaTau1){Tau1electron=true;}
               if (TMath::Abs(GenParticle_pdgId[r]) ==13 && GenParticle_motherIndex[r] == rigaTau1){Tau1muon=true;}
               if (TMath::Abs(GenParticle_pdgId[r]) >22 && GenParticle_motherIndex[r] == rigaTau2){Tau2jet=true;}
               if (TMath::Abs(GenParticle_pdgId[r]) == 11 && GenParticle_motherIndex[r] == rigaTau2){Tau2electron=true;}
               if (TMath::Abs(GenParticle_pdgId[r]) ==13 && GenParticle_motherIndex[r] == rigaTau2){Tau2muon=true;}
           }//end for gen part
       }// end if tau tau da H in evento
       
       //////////////////////////////////GUARDO IN FACCIA I CANALI DI DEC DEI TAU TAU E CONTO
       if(Tau1jet && Tau2jet){
           FHevent=true;
           FHEvent->Fill(1);
       }
       if((Tau1jet || Tau2jet) && (Tau1electron || Tau2electron)){
           elejet=true;
           elejetEvent->Fill(1);
       }
       if((Tau1jet || Tau2jet) && (Tau1muon || Tau2muon)){
           mujet=true;
           mujetEvent->Fill(1);
       }
       if((Tau1electron || Tau1muon) && (Tau2electron || Tau2muon)){
           FLevent=true;
           FLEvent->Fill(1);
       }
       ////////////////////////////////////COMBINO QUESTE INFORMAZIONI CON IL TRIGGER.... VEDO I DECADIMENTI DI H->tau tau PRODUZIONE ASSOCIATA DI W->mu
       if(FHevent && goodTrigger){
           GTFHevent=true;
           GTFHEvent->Fill(1);
       }
       if(elejet && goodTrigger){
           GTelejet=true;
           GTelejetEvent->Fill(1);
       }
       if(mujet && goodTrigger){
           GTmujet=true;
           GTmujetEvent->Fill(1);
       }
       if(FLevent && goodTrigger){
           GTFLevent=true;
           GTFLEvent->Fill(1);
       }
       
       if(goodTrigger){
           for(Int_t r=0; r<nGenParticle; r++){
               if (TMath::Abs(GenParticle_pdgId[r]) == 13) mupt_gen->Fill(GenParticle_pt[r]); }
       }
       
       /////////////////////////////////////////////////////////////////////////////////////////////////////
       /////////////FILTRO A MONTE PER WH... SOLO EVENTI DEL MIO CANALE!
       if(GTFHevent==false)continue;
       //if(GTmujet){
       
       */
       
       
       ///////////////////////// SELEZIONATE LE PARTICELLE ED OSSERVATA LA FISICA DEL CANALE IN ANALISI FACCIO HISTO PRELIMINARI
       
       hnMuon->Fill(nMuon);
       hnTau->Fill(nTau);
       hnElectron->Fill(nElectron);
       hnMET->Fill(nMET);
       hnMET_PU->Fill(nMET,puWeight);
       hMET->Fill(MET_met[0]);
       hMET_PU->Fill(MET_met[0],puWeight);
       
       ///////////////////////////////////////////////  ANALISI  ////////////////////////////////////////////////////////////////////////
       
       
       bool Trigger = false;
       for (unsigned int i = 0; i < hltpaths->size(); ++i) {
           //std::cout<<jentry<<" hltpaths "<<(*hltpaths)[i]<<" hltprescales "<<(*hltprescales)[i]<<" hltresults "<<(*hltresults)[i]<<std::endl;
           if ( ((*hltpaths)[i].find("HLT_IsoMu24_v")!= std::string::npos && ((*hltprescales)[i]==1))||((*hltpaths)[i].find("HLT_IsoMu24_eta2p1_v")!= std::string::npos && ((*hltprescales)[i]==1))){
               if ((*hltresults)[i] == 1 ) {
                   //	     std::cout<<jentry<<" hltpaths "<<(*hltpaths)[i]<<" hltprescales "<<(*hltprescales)[i]<<" hltresults "<<(*hltresults)[i]<<std::endl;
                   Trigger = true;
               }
               
           }}
       
       if(Trigger==false) continue;
       
       sizeAfterTrigger->Fill(1,puWeight);
       sizeAfterTrigger_PU->Fill(1,puWeight);
       //std::cout<<"++++++++++++++++++++++++++++++++++evento: "<< jentry<<std::endl;
       /*
        //////////////////////////////////////////////// Stampa Eventi ///////////////////////////////////////////////////////////
        
        cout<<"Run: "<<Event_run[0]<<" Event: "<<Event_run[1]<<" LS: "<<Event_run[2]<<endl;
        
        std::ofstream selEvents;
        std::stringstream txtName;
        
        txtName<<"/lustre/cms/store/user/radogna/Output_2012/VH125_B/Runs/Run_"<<Event_run[0]<<"_LS_"<<Event_run[2]<<"_Event_"<<Event_run[1]<<".txt";
        std::string txt = txtName.str();
        selEvents.open(txt.c_str());
        selEvents<<txt.c_str()<<std::endl;
        selEvents.close();
        
        ////////////////////////////////////////////////// Stampa Eventi //////////////////////////////////////////////////////////
        */
       
       /////////////////////////TAGLI VARI
       /// VERTEX CUT
       std::vector<int> indexVertex;
       Double_t sumPtmax_squared = 0;
       Int_t idmax = -1;
       Int_t NTVmax = -1;
       Int_t lmax = -1;
       Double_t zpv = -10;
       int nGoodVertices = 0;
       
       bool VertexCuts=false;
       
       for(Int_t l=0; l<nVertex; l++){
           VertexX->Fill(Vertex_x[l]);
           VertexY->Fill(Vertex_y[l]);
           VertexZ->Fill(Vertex_z[l]);
           VertexXY->Fill(Vertex_x[l],Vertex_y[l]);
           double z = Vertex_z[l];
           double rho = TMath::Sqrt(TMath::Power(Vertex_x[l],2)+TMath::Power(Vertex_y[l],2));
           if(Vertex_ndf[l] > 7 && fabs(z) < 24 && fabs(rho)<2)
           {
               ++nGoodVertices;
               if (nGoodVertices==1)
                   zpv = z;
           }
       }
       
       if (nGoodVertices!=0){VertexCuts =true;}
       
       if (VertexCuts==false) continue;
       //std::cout<<"good events for vertex selection "<<sizeVertex->GetEntries()<<std::endl;
       entries_after_vertex->Fill(1);
       entries_after_vertex_PU->Fill(1,puWeight);
       hnVertex->Fill(nVertex);
       hnVertex_PU->Fill(nVertex, puWeight);
       
       
       TLorentzVector MET;
       MET.SetPtEtaPhiM(MET_met[0], 0., MET_metphi[0], 0.);
       
       
       // for (Int_t p=0; p<nJet; p++ ){
       //   std::cout<<p<<" of "<<nJet<<" jet pt "<<Jet_pt[p]<<" jet eta  "<<Jet_eta[p]<<" jet phi  "<<Jet_phi[p]<<" b-discriminator  "<<Jet_combinedSecondaryVertexBJetTags[p]<<std::endl;}
       
       
       //////////////////////////// MUON CUT /////////////////////////////////////////
       std::vector<int> indexMuon;
       std::vector<int> indexMuonPt;
       std::vector<int> indexMuonAccept;
       std::vector<int> indexMuonID;
       std::vector<int> indexMuonISO;
       TLorentzVector mu; mu.SetPtEtaPhiE(1,0,0,0);
       Int_t muon_index=-1;
       TLorentzVector mu_tmp; mu_tmp.SetPtEtaPhiE(1,0,0,0);
       bool MuonCuts=false;
       bool MuonPt=false;
       Double_t muPt_max = 0;
       Int_t imax = -1;
       
       Double_t massa_trasversa=0;
       bool MtCut = true;
       Float_t dB_err = -10;
       Float_t dB = 10;
       std::vector<int>        indexMuonTrackGlob;
       std::vector<int>        indexMuonPixHits;
       std::vector<int>        indexMuonTrackHits;
       std::vector<int>        indexTrackD0;
       std::vector<int>        indexDistZ;
       std::vector<int>        indexNMatch;
       std::vector<int>        indexMuonChi2;
       std::vector<int>        indexMuonTrackdB;
       std::vector<int>        indexNChambers;
       std::vector<int>        indexNMatchStat;
       //std::cout<<" nMuon "<<nMuon<<std::endl;
       for (Int_t i=0 ; i<nMuon ; i++){
           mu_tmp.SetPtEtaPhiE(Muon_pt[i], Muon_eta[i], Muon_phi[i], Muon_energy[i]);
           //     std::cout<<" evento "<<jentry<<" muon reco pt "<<mu_tmp.Pt()<<" muon gen eta  "<<mu_tmp.Eta()<<" muon gen phi  "<<mu_tmp.Phi()<<" muon gen en  "<<mu_tmp.E()<<std::endl;
           //  if(muGen.DeltaR(mu_tmp)>0.5) continue;///////////////match mu
           //  std::cout<<" evento "<<jentry<<" muon reco after match pt "<<mu_tmp.Pt()<<" muon gen eta  "<<mu_tmp.Eta()<<" muon gen phi  "<<mu_tmp.Phi()<<" muon gen en  "<<mu_tmp.E()<<std::endl;
           indexMuonID.push_back(i);
           hPtMuon->Fill(Muon_pt[i],puWeight);
           hEtaMuon->Fill(Muon_eta[i],puWeight);
           hrelIso->Fill(Muon_pfRelIso[i],puWeight);
           if(!(Muon_pt[i]>24))continue;
           indexMuonPt.push_back(i);
           if (!(TMath::Abs(Muon_eta[i]) < 2.1)) continue;
           indexMuonAccept.push_back(i);
           if (!((Muon_isTrackerMuon[i]==1)&&(Muon_isGlobalMuonPromptTight[i]==1) && (Muon_isPFMuon[i]==1)))continue;
           //if (!((Muon_isTrackerMuon[i]==1)&&(Muon_isGlobalMuonPromptTight[i]==1)))continue;
           
           indexMuonTrackGlob.push_back(i);
           if(!(Muon_nChambers[i]>=2))continue;
           indexNChambers.push_back(i);
           if(!(Muon_nMatches[i]>=2))continue;
           if(!(Muon_nMatchedStations[i]>=2))continue;
           indexNMatchStat.push_back(i);
           //	    if(!(Muon_trkHits[i]>8.0))continue;
           //if(!(Muon_trackerLayersWithMeasurement[i]>8))continue;
           if(!(Muon_trackerLayersWithMeasurement[i]>5))continue;//5
           indexMuonTrackHits.push_back(i);
           if (!(Muon_pixHits[i]>=1)) continue;
           indexMuonPixHits.push_back(i);
           if(!(Muon_globalChi2[i]<10.0))continue;
           indexMuonChi2.push_back(i);
           if(!(TMath::Abs(Muon_dB[i])<0.02))continue;
           indexMuonTrackdB.push_back(i);
           //(TMath::Abs(Muon_trkD0[i])<0.045)&&
           //indexTrackD0.push_back(i);
           //          if(!(TMath::Abs(Muon_vtxDistZ[i])<0.2))continue;
           if(!(TMath::Abs(Muon_vz[i]-zpv)<0.2))continue;
           indexDistZ.push_back(i);
           //if (!(Muon_pfRelIsoDB04v2[i] < 0.1)) continue;
           if (!(Muon_pfRelIso[i] < 0.1)) continue;
           indexMuonISO.push_back(i);
           indexMuon.push_back(i);
           if(Muon_pt[i] > muPt_max){
               muPt_max = Muon_pt[i];
               imax = i;
           }
       }
       
       // end for sui mu
       if (indexMuonAccept.size()!=0){
           sizeMuonAccept->Fill(1,puWeight);}
       if(indexMuonPt.size()!=0){
           sizeMuonPt->Fill(1,puWeight);}
       if (indexMuonISO.size()!=0){
           sizeMuonISO->Fill(1,puWeight);}
       
       if(indexMuonTrackGlob.size()>0){
           sizeMuonTrackGlob->Fill(1,puWeight);
       }
       if(indexMuonPixHits.size()>0){
           sizeMuonPixHits->Fill(1,puWeight);
       }
       if(indexMuonTrackHits.size()>0){
           sizeMuonTrackHits->Fill(1,puWeight);
       }
       if(indexMuonChi2.size()>0){
           sizeMuonChi2->Fill(1,puWeight);
       }
       
       if (indexMuonTrackdB.size()>0){
           sizeMuondB->Fill(1,puWeight);
       }
       if(indexDistZ.size()>0){
           sizeMuonDistZ->Fill(1,puWeight);
       }
       
       if(indexNChambers.size()>0){
           sizeMuonChambers->Fill(1,puWeight);
       }
       
       if (indexMuonID.size()!=0){
           sizeMuonID->Fill(1,puWeight);}
       /*
        //////////////////////////////////////////////// Stampa Eventi ///////////////////////////////////////////////////////////
        
        cout<<"Run: "<<Event_run[0]<<" Event: "<<Event_run[1]<<" LS: "<<Event_run[2]<<endl;
        
        std::ofstream selEvents;
        std::stringstream txtName;
        
        txtName<<"/lustre/cms/store/user/radogna/Output_2012/VH125_B/Runs/Run_"<<Event_run[0]<<"_LS_"<<Event_run[2]<<"_Event_"<<Event_run[1]<<".txt";
        std::string txt = txtName.str();
        selEvents.open(txt.c_str());
        selEvents<<txt.c_str()<<std::endl;
        selEvents.close();
        
        ////////////////////////////////////////////////// Stampa Eventi //////////////////////////////////////////////////////////
        */
       
       if(indexNMatchStat.size()!=0){
	 sizeMuonMatchStat->Fill(1,puWeight);}
       if(indexMuon.size()!=0){
	 //sizeMuon->Fill(indexMuon.size(),puWeight);}
	 sizeMuon->Fill(1,puWeight);}
       if (indexMuon.size()>0){MuonCuts=true;}
       
       if(MuonCuts==false)continue;
       
       
       muon_index=indexMuon[0];
       mu.SetPtEtaPhiE(Muon_pt[muon_index], Muon_eta[muon_index], Muon_phi[muon_index],Muon_energy[muon_index] );
       //	  mu.SetPtEtaPhiM(Muon_pt[imax], Muon_eta[imax], Muon_phi[imax], 0.105);
       dB_err = Muon_dB[imax]/Muon_edB[imax];
       dB = Muon_dB[imax];
       hMuonPtReco->Fill(mu.Pt(),puWeight);
       hMuonEtaReco->Fill(mu.Eta(),puWeight);
       
       TLorentzVector mu1;
       mu1=mu;
       
       hnVertex2->Fill(nVertex);
       hnVertex_PU2->Fill(nVertex, puWeight);
       tagli[1]->Fill(1,puWeight);
       
       
       
       //////////////////////////////////////// TAU CUT
       
       std::vector<int> indexTauAccept1;
       std::vector<int> indexTauPt1;
       std::vector<int> indexTauDeltaZ1;
       std::vector<int> indexTauID1;
       std::vector<int> indexTauISO1;
       std::vector<int> indexTauAgainstLepton1;
       std::vector<int> indexTauAccept2;
       std::vector<int> indexTauPt2;
       std::vector<int> indexTauDeltaZ2;
       std::vector<int> indexTauID2;
       std::vector<int> indexTauISO2;
       std::vector<int> indexTauAgainstLepton2;
       std::vector<int> indexTau1DR;
       std::vector<int> indexTau1;
       std::vector<int> indexTau2;
       std::vector<int> indexTau2DRMu;
       std::vector<int> indexTau2DRTau1;
       std::vector<int> indexTau1AgainstMuon;
       std::vector<int> indexTau2AgMu;
       std::vector<int> indexTau1Fake;
       std::vector<int> indexTau1Good;
       std::vector<int> indexTau2Fake;
       std::vector<int> indexTau2Good;
       
       
       float fattore_tau = 0;
       std::vector<float> correzione;
       float fattore_tau1 = 0;
       std::vector<float> correzione1;
       
       Int_t tau1_indexprova=0; Int_t  tau2_indexprova=0; Int_t tau1_index=-1; Int_t tau2_index=-1;
       TLorentzVector tau1; tau1.SetPtEtaPhiM(1,0,0,0);
       TLorentzVector tau2; tau2.SetPtEtaPhiM(1,0,0,0);
       Int_t chargeTauTau=-1;
       bool TauCuts=false;
       bool TauCuts1Fake=false;
       bool TauCuts2Fake=false;
       bool TaulooseCuts=false;
       bool Tau1Pt=false;
       bool Tau2Pt=false;
       bool TauChargeCut=false;
       TLorentzVector tau_tmp; tau_tmp.SetPtEtaPhiM(1,0,0,0);
       Double_t tauPt_max = 0;
       Int_t jmax = -1;
       
       
       bool TauCuts1=false;
       bool TauCuts2=false;
       std::vector<int> indexEleIso;
       
       //std::cout<<" nTau "<<nTau<<std::endl;
       
       for(Int_t j=0; j<nTau; j++){
           hTau_jetEta->Fill(Tau_jetEta[j],puWeight);
           tau_tmp.SetPtEtaPhiM(Tau_pt[j], Tau_eta[j], Tau_phi[j], Tau_mass[j]);
           //           std::cout<<" evento "<<jentry<<" tau reco pt "<<tau_tmp.Pt()<<" tau gen eta  "<<tau_tmp.Eta()<<" tau gen phi  "<<tau_tmp.Phi()<<" tau gen en  "<<tau_tmp.E()<<std::endl;
           //if(!(tau1Gen.DeltaR(tau_tmp)<0.5||tau2Gen.DeltaR(tau_tmp)<0.5)) continue; /////////////////////////////////// match tau 1
           // std::cout<<" evento "<<jentry<<" tau 1 reco after match pt "<<tau_tmp.Pt()<<" tau gen eta  "<<tau_tmp.Eta()<<" tau gen phi  "<<tau_tmp.Phi()<<" tau gen en  "<<tau_tmp.E()<<std::endl;
           
           indexTau1DR.push_back(j);
           if (tau_tmp.DeltaR(mu)<=  0.5) continue;
           indexTauDeltaZ1.push_back(j);
           if(!(Tau_pt[j]>45)) continue;
           indexTauPt1.push_back(j);
           if (!(TMath::Abs(Tau_eta[j]) < 2.3)) continue;
           indexTauAccept1.push_back(j);
           if (!(Tau_decayModeFinding[j] == 1)) continue;
           indexTauID1.push_back(j);
           if (!(Tau_byTightCombinedIsolationDeltaBetaCorr[j] == 1)) continue;
           indexTauISO1.push_back(j);
           if(! (Tau_againstMuonTight[j] == 1)) continue;
           indexTau1AgainstMuon.push_back(j);
           if (!(Tau_againstElectronLoose[j] == 1))continue;
           indexTauAgainstLepton1.push_back(j);
           //if(!(TMath::Abs(Tau_zvertex[j]-zpv)<0.2)) continue;
           // if (tau_tmp.DeltaR(mu)<=  0.5) continue;
           // indexTauDeltaZ1.push_back(j);
           indexTau1.push_back(j);
           
           
           // std::cout<<" evento "<<jentry<<" tau 1 reco after selection pt "<<tau_tmp.Pt()<<" tau gen eta  "<<tau_tmp.Eta()<<" tau gen phi  "<<tau_tmp.Phi()<<" tau gen en  "<<tau_tmp.E()<<std::endl;
           
       } //for tau
       
       
       if (indexTauAccept1.size()>0){
           sizeTauAccept1->Fill(1,puWeight);
       }
       if(indexTau1DR.size()>0){
           sizeTau1DR->Fill(1,puWeight);
           
       }
       
       if (indexTauPt1.size()>0){
           sizeTauPt1->Fill(1,puWeight);
       }
       
       if (indexTauISO1.size()>0){
           sizeTauISO1->Fill(1,puWeight);
       }
       if (indexTauDeltaZ1.size()>0){
           sizeTauDeltaZ1->Fill(1,puWeight);
       }
       if (indexTauID1.size()>0){
           sizeTauID1->Fill(1,puWeight);
       }
       if (indexTau1AgainstMuon.size()>0){
           sizeTau1AgMu->Fill(1,puWeight);}
       
       if (indexTauAgainstLepton1.size()>0){
           sizeTauAgainstLepton1->Fill(1,puWeight);
       }
       if (indexTau1.size()!=0){
           nTau_baseSelection1->Fill(1,puWeight);}
       
       if (indexTau1.size()>0){TauCuts1 = true;}
       
       if(TauCuts1 ==false)continue;
       tau1.SetPtEtaPhiM(Tau_pt[indexTau1[0]], Tau_eta[indexTau1[0]], Tau_phi[indexTau1[0]], Tau_mass[indexTau1[0]]);
       tagli[2]->Fill(1,puWeight);
       
       std::vector<int> indexZMu;
       if(!(TMath::Abs(Muon_vz[indexMuon[0]]-Tau_zvertex[indexTau1[0]])<0.14))continue;
       indexZMu.push_back(1);
       if(indexZMu.size()>0){sizeMuTau1Z->Fill(1,puWeight);}
       
       
       hnVertex_PU3->Fill(nVertex, puWeight);
       
       
       TLorentzVector  Z;
       Z.SetPtEtaPhiM(1.,0.,0.,0.);
       
       Double_t m_MuMet=TMath::Sqrt(2*(mu1.Pt())*(MET.Pt())*(1-TMath::Cos(mu1.DeltaPhi(MET))));
       MuTau1_AfterTau1->Fill(Z.M(),puWeight);
       MuMET_AfterTau1->Fill(m_MuMet,puWeight);
       Tau1Pt_AfterTau1->Fill(tau1.Pt(),puWeight);
       MuPt_AfterTau1->Fill(mu1.Pt(),puWeight);
       
       
       for(Int_t j=0; j<nTau; j++){
           tau_tmp.SetPtEtaPhiM(Tau_pt[j], Tau_eta[j], Tau_phi[j], Tau_mass[j]);
           //  if(!(tau2Gen.DeltaR(tau_tmp)<0.5||tau1Gen.DeltaR(tau_tmp)<0.5)) continue;
           //std::cout<<" evento "<<jentry<<" tau 2 reco after match pt "<<tau_tmp.Pt()<<" tau gen eta  "<<tau_tmp.Eta()<<" tau gen phi  "<<tau_tmp.Phi()<<" tau gen en  "<<tau_tmp.E()<<std::endl;
           /////////////////////////////////// match tau 1
           for(Int_t k=0; k<indexTau1.size(); k++){  if(indexTau1[k] != j) indexTauDeltaZ2.push_back(j);}
           //  if (tau_tmp.DeltaR(tau1)<=  0.5) continue;
           //   indexTau2DRTau1.push_back(j);
           if (tau_tmp.DeltaR(mu)<=  0.5) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){  if(indexTau1[k] != j) indexTau2DRMu.push_back(j);   }
           
           
           if(!(Tau_pt[j]>30)) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j) indexTauPt2.push_back(j);
           }
           
           if (!(TMath::Abs(Tau_eta[j]) < 2.3)) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j) indexTauAccept2.push_back(j);
           }
           
           if (!(Tau_decayModeFinding[j] == 1)) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j) indexTauID2.push_back(j);
           }
           
           if (!(Tau_byMediumCombinedIsolationDeltaBetaCorr[j] == 1)) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j) indexTauISO2.push_back(j);
           }
           
           if(!(Tau_againstMuonTight[j]==1))continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j) indexTau2AgMu.push_back(j);
           }
           
           if (!(Tau_againstElectronMedium[j] ==1)) continue;
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j)  indexTauAgainstLepton2.push_back(j);
           }
           
           ///////pezzetto mancante///////////
           //if(!(TMath::Abs(Tau_zvertex[j]-zpv)<0.2)) continue;
           /*  if(!(tau_tmp.DeltaR(mu))>0.5)continue;
            for(Int_t k=0; k<indexTau1.size(); k++){
            if(indexTau1[k] != j) indexTau2DRMu.push_back(j);
            }
            */
           for(Int_t k=0; k<indexTau1.size(); k++){
               if(indexTau1[k] != j)  indexTau2.push_back(j);
           }
           
           //         std::cout<<" evento "<<jentry<<" tau 2 reco after selection pt "<<tau_tmp.Pt()<<" tau gen eta  "<<tau_tmp.Eta()<<" tau gen phi  "<<tau_tmp.Phi()<<" tau gen en  "<<tau_tmp.E()<<std::endl;
       }
       
       if (indexTau2DRMu.size()>0){
           sizeTau2DRMu->Fill(1,puWeight);
       }
       
       /*if (indexTau2DRTau1.size()>0){
        sizeTau2DRTau1->Fill(1,puWeight);
        }*/
       
       if (indexTauAccept2.size()>0){
           sizeTauAccept2->Fill(1,puWeight);
       }
       if (indexTauPt2.size()>0){
           sizeTauPt2->Fill(1,puWeight);
       }
       if (indexTauDeltaZ2.size()>0){
           sizeTauDeltaZ2->Fill(1,puWeight);
       }
       if (indexTauID2.size()>0){
           sizeTauID2->Fill(1,puWeight);
       }
       if (indexTauISO2.size()>0){
           sizeTauISO2->Fill(1,puWeight);
       }
       
       
       if (indexTau2AgMu.size()>0){
           sizeTau2AgMu->Fill(1,puWeight);
       }
       
       
       if (indexTauAgainstLepton2.size()>0){
           sizeTauAgainstLepton2->Fill(1,puWeight);
       }
       
       if (indexTau2.size()!=0){
           //nTau_baseSelection2->Fill(indexTau2.size(),puWeight);}
           nTau_baseSelection2->Fill(1,puWeight);}
       
       if (indexTau2.size()>0){TauCuts2 = true;}
       if(TauCuts2 ==false)continue;
       // tagli[4]->Fill(1,puWeight);
       tau2.SetPtEtaPhiM(Tau_pt[indexTau2[0]], Tau_eta[indexTau2[0]], Tau_phi[indexTau2[0]], Tau_mass[indexTau2[0]]);
       
       /*	  std::vector<int> indexZtau;
        
        if(!(TMath::Abs(Tau_zvertex[indexTau1[0]]-Tau_zvertex[indexTau2[0]])<0.14))continue;
        indexZtau.push_back(1);
        if(indexZtau.size()>0){sizeTauZDist->Fill(1,puWeight);}
        */            //sizeMuTau1Z->Fill(1,puWeight);
       /*std::vector<int> indexZMu;
        if(!(TMath::Abs(Mu_z-Tau_zvertex[indexTau1[0]])<0.14))continue;
        indexZMu.push_back(1);
        if(indexZMu.size()>0){sizeMuTau1Z->Fill(1,puWeight);}
        */
       
       TLorentzVector massM1T2, massM2T2;
       TLorentzVector massM1T1, massM2T1;
       TLorentzVector MH = tau1 + tau2;
       TLorentzVector W = mu1+ MET;
       // Z = mu1 + mu2;
       TLorentzVector WH=mu1+tau1+tau2;
       massM1T1 = mu1 + tau1;
       massM1T2 = mu1 + tau2;
       
       Double_t Mu_z=Vertex_z[0]+Muon_vz[imax];
       
       
       
       
       ///////////// SEGNALE almeno 1Tau1 + 1Tau2 buoni
       bool segnale=false;
       
       //	if(Tau1buono && Tau2buono){
       std::vector<int> indexTau1coppiaSegnale;
       std::vector<int> indexTau2coppiaSegnale;
       std::vector<float> pesoSegnale;
       std::vector<int> indexCoppiaSegnale;
       std::vector<int> indexDR;
       std::vector<int> indexCharge;
       std::vector<int> indexZCut;
       std::vector<int> indexMET;
       std::vector<int>	  extramuon;
       std::vector<int> extraele;
       std::vector<int>  extrab;
       std::vector<int> indexZtau;
       std::vector<int> indexMtmumet;
       //  std::cout<<jentry<<" caso tau1+tau2 "<<std::endl;
       Double_t coppie=0;
       for(int t=0;t<indexTau1.size();t++){
           tau1.SetPtEtaPhiM(Tau_pt[indexTau1[t]], Tau_eta[indexTau1[t]], Tau_phi[indexTau1[t]], Tau_mass[indexTau1[t]]);
           for(int k=0;k<indexTau2.size();k++){
               //     if(!(indexTau1[t]!=indexTau2[k]))continue;
               //	       indexDR.push_back(1);
               // cout<<jentry<<" DR   "<<indexDR.size()<<endl;
               //	      sizeTau2DRTau1->Fill(1,puWeight);
               tau2.SetPtEtaPhiM(Tau_pt[indexTau2[k]], Tau_eta[indexTau2[k]], Tau_phi[indexTau2[k]], Tau_mass[indexTau2[k]]);
               if(tau1.DeltaR(tau2)<=0.5) continue;
               indexTau2DRTau1.push_back(1);
               
               
               
               if(!(TMath::Abs(Tau_zvertex[indexTau1[t]]-Tau_zvertex[indexTau2[k]])<0.14))continue;
               indexZtau.push_back(1);
               
               
               massM1T1 = mu1 + tau1;
               massM1T2 = mu1 + tau2;
               massM2T1 = mu + tau1;
               massM2T2 = mu + tau2;
               MH = tau1 + tau2;
               // Z=mu+tau1;
               if(!((Tau_charge[indexTau1[t]]+Tau_charge[indexTau2[k]]) == 0)) continue;
               indexCharge.push_back(1);
               
               
               double Mtmumet=TMath::Sqrt(2*(mu.Pt())*(MET.Pt())*(1-TMath::Cos(mu.DeltaPhi(MET))));
               MtMuMetVsMet_afterCharge->Fill(Mtmumet,(MET_met[0]));
               //  cout<<jentry<<" mt mumet  "<<Mtmumet<<endl;
               
               /*     if(!(MET_met[0]>=20))continue;
                indexMET.push_back(1);
                */
               
               /////////////////////////zero goodMu/////////////////////////////////////////////////
               std::vector<int> indexExtraMuon;
               TLorentzVector muschifo;
               muschifo.SetPtEtaPhiM(1.,0.,0.,0.);
               for (Int_t i=0 ; i<nMuon ; i++){
                   muschifo.SetPtEtaPhiM(Muon_pt[i], Muon_eta[i], Muon_phi[i], 0.105);
                   if (!(muschifo.DeltaR(mu)>0.5) ) continue;
                   //if (!(TMath::Abs(Muon_eta[i]) < 2.4)) continue;
                   if (!(TMath::Abs(Muon_eta[i]) < 2.1)) continue;
                   if(!(TMath::Abs(Muon_vz[i]-Tau_zvertex[indexTau1[t]])<0.14))continue;
                   if (!(Muon_pt[i] > 15)) continue;
                   if (!((Muon_isTrackerMuon[i]==1)&&(Muon_isGlobalMuonPromptTight[i]==1)&& (Muon_isPFMuon[i]==1)))continue;
                   //if (!((Muon_isTrackerMuon[i]==1)&&(Muon_isGlobalMuonPromptTight[i]==1)))continue;
                   indexExtraMuon.push_back(i);
               }
               if(!(indexExtraMuon.size()==0))continue;
               //     NoExtraMuon->Fill(1,puWeight);
               extramuon.push_back(1);
               
               
               
               ////////////////////////////////////////////ZERO ELETTRONI//////////////////////////////////////
               
               
               
               std::vector<int> indexEle;
               TLorentzVector el_prova;
               el_prova.SetPtEtaPhiM(1,0,0,0);
               bool ElectronCuts=false;
               bool eleMin20=false;
               bool eleGreat20=false;
               
               
               for (Int_t h=0; h<nElectron; h++ ){
                   
                   TLorentzVector el_prova;
                   el_prova.SetPtEtaPhiE(1,0,0,0);
                   el_prova.SetPtEtaPhiM(Electron_pt[h], Electron_eta[h], Electron_phi[h], Electron_energy[h]);
                   
                   if (!(Electron_pt[h] > 10.0) ) continue;
                   // indexElePt.push_back(h);
                   
                   if (!(TMath::Abs(Electron_eta[h]) < 2.5) ) continue;
                   if (!(TMath::Abs(Electron_eta[h]) < 1.4442 || TMath::Abs(Electron_eta[h]) > 1.566)) continue; //crackVeto
                   if(!(TMath::Abs(Electron_vz[h]-Tau_zvertex[indexTau2[k]])<0.14))continue;
                   
                   //	if(!(Electron_missingHits[h] < 1)) continue;
                   //	if(!(Electron_hasMatchedConv[h] < 1)) continue;
                   //if (!(TMath::Abs(Electron_dB[h]) < 0.02) ) continue;
                   
                   
                   
                   bool ele1_l20=false;
                   bool ele2_l20=false;
                   bool ele3_l20=false;
                   bool ele_l20=false;
                   //		cout<<h<< " of  "<<nElectron<<" idMVA "<<Electron_mvaPOGNonTrig[h]<<endl;
                   // replaced Electron_idMVA with Electron_mvaPOGNonTrig
                   if(Electron_pt[h] < 20 && TMath::Abs(Electron_scEta[h])<0.8 && Electron_mvaPOGNonTrig[h] > 0.925) {
                       ele1_l20=true;}
                   
                   if(Electron_pt[h] < 20 && (TMath::Abs(Electron_scEta[h])<1.479)  && TMath::Abs(Electron_scEta[h])>0.8 && (Electron_mvaPOGNonTrig[h] >  0.915) ) {
                       ele2_l20=true;}
                   
                   if(Electron_pt[h] < 20 && TMath::Abs(Electron_scEta[h])>1.479 &&   (Electron_mvaPOGNonTrig[h] >  0.965) ) {
                       ele3_l20=true;}
                   
                   if((ele1_l20 || ele2_l20 || ele3_l20)==true) ele_l20=true;
                   
                   bool ele1_g20=false;
                   bool ele2_g20=false;
                   bool ele3_g20=false;
                   bool ele_g20=false;
                   
                   if(Electron_pt[h] > 20 && TMath::Abs(Electron_scEta[h])<0.8 && (Electron_mvaPOGNonTrig[h] > 0.905 )) {
                       ele1_g20=true;}
                   
                   if(Electron_pt[h] > 20 && (TMath::Abs(Electron_scEta[h])<1.479 ) && (TMath::Abs(Electron_scEta[h])>0.8 ) && (Electron_mvaPOGNonTrig[h] >  0.955) ) {
                       ele2_g20=true;}
                   
                   if(Electron_pt[h] > 20 && TMath::Abs(Electron_scEta[h])>1.479 && (Electron_mvaPOGNonTrig[h] >   0.975) ) {
                       ele3_g20=true;
                   }
                   
                   if((ele1_g20 || ele2_g20 || ele3_g20)==true) ele_g20=true;
                   
                   bool eleFinal=false;
                   if(ele_l20 || ele_g20) eleFinal=true;
                   
                   if(eleFinal==false)continue;
                   indexEle.push_back(h);
               }
               
               
               
               
               if (!(indexEle.size()==0))continue;
               extraele.push_back(1);
               // if(extraele.size()>0) sizeZeroEle->Fill(1,puWeight);
               
               
               //////////////////////////////////jetCuts/////////////////////////////
               std::vector<int> indexJet;
               std::vector<int> indexJetMatch;
               bool JetCuts=false;
               bool JetCutsMatch=false;
               TLorentzVector jet; jet.SetPtEtaPhiE(1,0,0,0);
               
               //std::cout<<"Run: "<<Event_run[0]<<" Event: "<<Event_run[1]<<" LS: "<<Event_run[2]<<endl;
               //std::cout<<"++++++++++++++++++++"<<std::endl;
               //std::cout<<" nJet "<<nJet<<std::endl;
               
               
               
               for (Int_t p=0; p<nJet; p++ ){
                   //	std::cout<<p<<" of "<<nJet<<" jet pt "<<Jet_pt[p]<<" jet eta  "<<Jet_eta[p]<<" jet phi  "<<Jet_phi[p]<<" b-discriminator  "<<Jet_combinedSecondaryVertexBJetTags[p]<<std::endl;
                   if (!( Jet_pt[p] > 20.0 )) continue;
                   if (!( TMath::Abs(Jet_eta[p]) < 2.4 )) continue;
                   
                   if(!(Jet_combinedSecondaryVertexBTag[p]>0.679))continue;
                   //		if(!(Jet_simpleSecondaryVertexHighEffBTag[p]>1.74))continue;
                   //	        if (!( Jet_trackCountingHighEffBTag[p] > 3.3)) continue;
                   bdiscrAleternative->Fill(Jet_simpleSecondaryVertexHighEffBTag[p],puWeight);
                   hPtJet_baseSelection->Fill(Jet_pt[p],puWeight);
                   indexJet.push_back(p);
                   
               } //fine loop jet
               nJet_baseSelection->Fill(indexJet.size(),puWeight);
               if(indexJet.size()==0){JetCuts=true;}
               
               //  if(JetCuts==false)continue;
               //	extrab.push_back(1);
               /*//////////////////////////////////////////////// Stampa Eventi ///////////////////////////////////////////////////////////
                
                cout<<"Run: "<<Event_run[0]<<" Event: "<<Event_run[1]<<" LS: "<<Event_run[2]<<endl;
                
                std::ofstream selEvents;
                std::stringstream txtName;
                
                txtName<<"/lustre/cms/store/user/radogna/Output_2012/VH125_B/Runs/Run_"<<Event_run[0]<<"_LS_"<<Event_run[2]<<"_Event_"<<Event_run[1]<<"_noB.txt";
                std::string txt = txtName.str();
                selEvents.open(txt.c_str());
                selEvents<<txt.c_str()<<std::endl;
                selEvents.close();
                
                ////////////////////////////////////////////////// Stampa Eventi //////////////////////////////////////////////////////////
                */
               
               /*	      if(!(TMath::Abs(Tau_zvertex[indexTau1[0]]-Tau_zvertex[indexTau2[0]])<0.14))continue;
                indexZtau.push_back(1);
                if(indexZtau.size()>0){sizeTauZDist->Fill(1,puWeight);}
                //sizeMuTau1Z->Fill(1,puWeight);
                if(!(TMath::Abs(Mu_z-Tau_zvertex[indexTau1[0]])<0.14))continue;
                indexZMu.push_back(1);
                if(indexZMu.size()>0){sizeMuTau1Z->Fill(1,puWeight);}
                */
               if((Tau_charge[indexTau1[t]]+Muon_charge[indexMuon[0]]) == 0) {
                   Z=mu+tau1;
                   TLorentzVector tauOS;
                   //	tauOS=tau1;
                   //	double MtMuTau=TMath::Sqrt(2*(mu.Pt())*(tauOS.Pt())*(1-TMath::Cos(mu.DeltaPhi(tauOS))));
                   MtMuTauVSMET_afterCharge->Fill(Z.M(),MET_met[0]);
                   
               }
               if((Tau_charge[indexTau2[k]]+Muon_charge[indexMuon[0]]) == 0) {
                   Z=mu+tau2;
                   TLorentzVector tauOS;
                   //	       tauOS=tau2;
                   //	       double MtMuTau=TMath::Sqrt(2*(mu.Pt())*(tauOS.Pt())*(1-TMath::Cos(mu.DeltaPhi(tauOS))));
                   MtMuTauVSMET_afterCharge->Fill(Z.M(),MET_met[0]);
               }
               
               
               double cosTauLead = -99;
               double cosTauSubLead = -99;
               cosTauLead = cos(mu.Phi() - tau1.Phi());
               cosTauSubLead = cos(mu.Phi() - tau2.Phi());
               cosTauLeadVSMtMuMet_afterCharge->Fill(cosTauLead, Mtmumet);
               cosTauSubVSMtMuMet_afterCharge->Fill(cosTauSubLead, Mtmumet);
               
               
               cosTauLeadVSMet_afterCharge->Fill(cosTauLead,MET_met[0] );
               cosTauSubVSMet_afterCharge->Fill(cosTauSubLead,MET_met[0] );
               
               ///////////////////////////////////////ZCUT///////////////////////////////////////////////////////////
               
               
               if(((Z.M()<80) && (MH.Pt()<50)))continue;
               //      if((Z.M()<80) && (MET_met[0]<25))continue;
               indexZCut.push_back(1);
               if(JetCuts==false)continue;
               extrab.push_back(1);
               //if(!(MET_met[0]>=20))continue;
               if(!(mvaMET_met[0]>=20))continue; //use MvaMET
               indexMET.push_back(1);
               if(!(Mtmumet>20))continue;
               indexMtmumet.push_back(1);
               
               //////////////////////////////////////////////// Stampa Eventi ///////////////////////////////////////////////////////////
               
               cout<<"Run: "<<Event_run[0]<<" Event: "<<Event_run[1]<<" LS: "<<Event_run[2]<<endl;
               
               std::ofstream selEvents;
               std::stringstream txtName;
               
               txtName<<"/lustre/cms/store/user/rvenditti/Output_PatUniversal/Run_"<<Event_run[0]<<"_LS_"<<Event_run[2]<<"_Event_"<<Event_run[1]<<".txt";
               std::string txt = txtName.str();
               selEvents.open(txt.c_str());
               selEvents<<txt.c_str()<<std::endl;
               selEvents.close();
               
               ////////////////////////////////////////////////// Stampa Eventi //////////////////////////////////////////////////////////
               
               
               
               segnale=true;
               
               indexTau1coppiaSegnale.push_back(indexTau1[t]);
               indexTau2coppiaSegnale.push_back(indexTau2[k]);
               indexCoppiaSegnale.push_back(1);
               
               
               //std::cout<<jentry<<"coppie"<<g<<std::endl;
           }}
       
       if (indexTau2DRTau1.size()>0){sizeTau2DRTau1->Fill(1,puWeight);}
       if(indexCharge.size()>0){tagli[6]->Fill(1,puWeight);}
       if(indexZtau.size()>0){sizeTauZDist->Fill(1,puWeight);}
       if(indexZCut.size()>0){ZCut->Fill(1,puWeight);}
       if(extrab.size()>0) sizeJetMatch->Fill(1,puWeight);
       if(extraele.size()>0) sizeZeroEle->Fill(1,puWeight);
       if(extramuon.size()>0) NoExtraMuon->Fill(1,puWeight);
       if(indexMET.size()>0){tagli[4]->Fill(1,puWeight);}
       if(indexMtmumet.size()>0){sizeMtmumet->Fill(1,puWeight);}
       
       
       Double_t doppioniSegnale=0;
       Double_t coppieSegnale=0;
       
       for(int n=0;n<indexCoppiaSegnale.size();n++){
           bool cacca=false;
           for(int m=0;m<indexCoppiaSegnale.size();m++){
               if(n==m)continue;
               
               if((indexTau1coppiaSegnale[n]==indexTau2coppiaSegnale[m])&&(indexTau2coppiaSegnale[n]==indexTau1coppiaSegnale[m])){
                   if(Tau_pt[indexTau1coppiaSegnale[n]]>Tau_pt[indexTau2coppiaSegnale[n]]){
                       pesoSegnale.push_back(1);}
                   if(Tau_pt[indexTau1coppiaSegnale[n]]<Tau_pt[indexTau2coppiaSegnale[n]]){
                       pesoSegnale.push_back(0);}
                   
                   //std::cout<<" mmm "<<std::endl;
                   doppioniSegnale++;
                   //		pesoSegnale.push_back(0.5);
                   cacca=true;
                   //		cout<<jentry<<" pt   "<<Tau_pt[indexTau1coppiaSegnale[n]]<<"  index1    "<<indexTau1coppiaSegnale[n]<<endl;
                   //cout<<jentry<<" pt   "<<Tau_pt[indexTau2coppiaSegnale[n]]<<"  index2    "<<indexTau2coppiaSegnale[n]<<endl;
                   
               }
           }
           if(cacca==false){pesoSegnale.push_back(1);}
       }
       
       coppieSegnale=indexCoppiaSegnale.size()-doppioniSegnale/2;
       
       
       if(segnale){
           Double_t peso=1;
           peso=1/coppieSegnale;
           
           for(Int_t c=0; c<indexCoppiaSegnale.size(); c++){
               tau1.SetPtEtaPhiM(Tau_pt[indexTau1coppiaSegnale[c]], Tau_eta[indexTau1coppiaSegnale[c]], Tau_phi[indexTau1coppiaSegnale[c]], Tau_mass[indexTau1coppiaSegnale[c]]);
               tau2.SetPtEtaPhiM(Tau_pt[indexTau2coppiaSegnale[c]], Tau_eta[indexTau2coppiaSegnale[c]], Tau_phi[indexTau2coppiaSegnale[c]], Tau_mass[indexTau2coppiaSegnale[c]]);
               
               massM1T1 = mu1 + tau1;
               massM1T2 = mu1 + tau2;
               massM2T1 = mu + tau1;
               massM2T2 = mu + tau2;
               MH = tau1 + tau2;
               Z=mu1+tau1;
               // std::cout<<jentry<<" peso segnale  "<<pesoSegnale.at(c)<<" peso  "<<peso<<" puWeight  "<<puWeight<<endl;;
               hTau1Pt[7]->Fill(tau1.Pt(), pesoSegnale.at(c)*peso*puWeight);
               hTau1Eta[7]->Fill(tau1.Eta(),peso*pesoSegnale.at(c)*puWeight);
               hTau2Pt[7]->Fill(tau2.Pt(),peso*pesoSegnale.at(c)*puWeight);
               hTau2Eta[7]->Fill(tau2.Eta(),peso*pesoSegnale.at(c)*puWeight);
               hMuon1Pt[7]->Fill(mu1.Pt(),peso*pesoSegnale.at(c)*puWeight);
               hMuon1Eta[7]->Fill(mu1.Eta(),peso*pesoSegnale.at(c)*puWeight);
               massainv_TauTau[7]->Fill(MH.M(),peso*pesoSegnale.at(c)*puWeight);
               mass_Mu1Mu2->Fill(Z.M(),peso*pesoSegnale.at(c));
               
               tagli[7]->Fill(1,peso*pesoSegnale.at(c)*puWeight);
               
               double Mtmumet=TMath::Sqrt(2*(mu.Pt())*(MET.Pt())*(1-TMath::Cos(mu.DeltaPhi(MET))));
               //      MtMuMetVsMet_afterZ->Fill(Mtmumet,(MET_met[0]));
               
               
               /*	      if((Tau_charge[indexTau2coppiaSegnale[c]]+Muon_charge[indexMuon[0]]) == 0){
                TLorentzVector tauOS;
                tauOS=tau2;
                double MtMuTau=TMath::Sqrt(2*(mu.Pt())*(tauOS.Pt())*(1-TMath::Cos(mu.DeltaPhi(tauOS))));
                MtMuTauVSMET_afterZ->Fill(Z.M(),MET_met[0]);}
                
                if((Tau_charge[indexTau1coppiaSegnale[c]]+Muon_charge[indexMuon[0]]) == 0){
                TLorentzVector tauOS;
                tauOS=tau1;
                double MtMuTau=TMath::Sqrt(2*(mu.Pt())*(tauOS.Pt())*(1-TMath::Cos(mu.DeltaPhi(tauOS))));
                MtMuTauVSMET_afterZ->Fill(Z.M(),MET_met[0]);}
                */	      double cosTauLead = -99;
               double cosTauSubLead = -99;
               cosTauLead = cos(mu.Phi() - tau1.Phi());
               cosTauSubLead = cos(mu.Phi() - tau2.Phi());
               
               cosTauLeadVSMtMuMet_afterZ->Fill(cosTauLead, Mtmumet);
               cosTauSubVSMtMuMet_afterZ->Fill(cosTauSubLead, Mtmumet);
               
               cosTauLeadVSMet_afterZ->Fill(cosTauLead,MET_met[0] );
               cosTauSubVSMet_afterZ->Fill(cosTauSubLead,MET_met[0] );
               
           }
           
       }//se ho almeno una coppia di segnale!!!
       //	} //(Tau1buono && Tau2buono)
       
       
       
       
       //}
       // stampa qualcosa per vedere se gira...
       if (jentry % 10000 == 0 ){
           std::cout << "jentry = " << jentry << std::endl;}
   } //parentesi del ciclo su tutti gli eventi
    
    std::cout<<"Htot; "<<H_tot->GetEntries()<<std::endl;
    std::cout<<"H->tau tau; "<<tautauEvent->GetEntries()<<std::endl;
    std::cout<<"H->tau tau controllo; "<<controlloTauTau->GetEntries()<<std::endl;
    std::cout<<"Wtot; "<<W_tot->GetEntries()<<std::endl;
    std::cout<<"Ztot; "<<Z_tot->GetEntries()<<std::endl;
    std::cout<<"t tot; "<<t_tot->GetEntries()<<std::endl;
    std::cout<<"mu status 1 tot; "<<muonStatus1->GetEntries()<<std::endl;
    std::cout<<"CANALI DI DECADIMENTO DEL TAU TAU nel canale in analisi"<<std::endl;
    std::cout<<"eventi full hadronic; "<<FHEvent->GetEntries()<<std::endl;
    std::cout<<"eventi e + jet; "<<elejetEvent->GetEntries()<<std::endl;
    std::cout<<"eventi m + jet; "<<mujetEvent->GetEntries()<<std::endl;
    std::cout<<"eventi full leptonic; "<<FLEvent->GetEntries()<<std::endl;
    std::cout<<"TRIGGER PLUS DECADIMENTI DEL TAU DEGLI EVENTI TRIGGERATI"<<std::endl;
    std::cout<<"muon status 1 in eventi con W;  "<<WplusMuon->GetEntries()<<std::endl;
    std::cout<<"mu di status 3 da W tot; "<<muonWstatus3->GetEntries()<<std::endl;
    std::cout<<"mu di status 1 da W tot; "<<muonW->GetEntries()<<std::endl;
    std::cout<<"eventi full hadronic; "<<GTFHEvent->GetEntries()<<std::endl;
    std::cout<<"eventi e + jet; "<<GTelejetEvent->GetEntries()<<std::endl;
    std::cout<<"eventi m + jet; "<<GTmujetEvent->GetEntries()<<std::endl;
    std::cout<<"eventi full leptonic; "<<GTFLEvent->GetEntries()<<std::endl;
    std::cout<<"+++++++++++++++++ABOUT CUTS+++++++++++++++++++++++++++ "<<std::endl;
    std::cout<<" eventi con un match tra mu gen e reco; "<<MuonMatchEvent->GetEntries()<<std::endl;
    //std::cout<<" eventi con un match tra mu gen e reco che supera i tagli; "<<MuonCompatibleEvent->GetEntries()<<std::endl;
    std::cout<<" eventi con un match tra 2 tau gen e reco; "<<TauMatchEvent->GetEntries()<<std::endl;
    
    
    
    
    
    
    std::cout<<"before filter;"<<tagli[0]->Integral(0,3)<<std::endl;
    std::cout<<" WH filter;"<<hnMET_PU->Integral(0,32)<<std::endl;
    std::cout<<" Trigger;"<<sizeAfterTrigger->Integral(0,32)<<std::endl;
    std::cout<<"vertex cut;"<<entries_after_vertex_PU->Integral(0,3)<<std::endl;
    std::cout<<" Muon Pt;"<<sizeMuonPt->Integral(0,32)<<std::endl;
    
    std::cout<<" Muon Eta;"<<sizeMuonAccept->Integral(0,3)<<std::endl;
    std::cout<<" Muon Tracker && Global;"<< sizeMuonTrackGlob->Integral(0,32)<<std::endl;
    std::cout<<" Muon chambers=>2;"<<sizeMuonChambers->Integral(0,32)<<std::endl;
    std::cout<<" Muon Match =>2;"<<sizeMuonMatchStat->Integral(0,32)<<std::endl;
    
    std::cout<<" muon Tracker Hits;"<< sizeMuonTrackHits->Integral(0,32)<<std::endl;
    std::cout<<" muon Pixel Hits;"<< sizeMuonPixHits->Integral(0,32)<<std::endl;
    
    std::cout<<" muon Chi2;"<< sizeMuonChi2->Integral(0,32)<<std::endl;
    std::cout<<" muon dB;"<< sizeMuondB->Integral(0,32)<<std::endl;
    std::cout<<" muon Dist Z;"<< sizeMuonDistZ->Integral(0,32)<<std::endl;
    std::cout<<" muon PFRel Iso;"<<sizeMuonISO->Integral(0,3)<<std::endl;
    
    //std::cout<<" muon ID;"<<sizeMuonID->Integral(0,3)<<std::endl;
    //std::cout<<"Muon id;"<<tagli_7->Integral(0,3)<<std::endl;
    std::cout<<" DR(Mu,tau1);"<<sizeTau1DR->Integral(0,31)<<std::endl;
    std::cout<<" Tau1 pt;"<<sizeTauPt1->Integral(0,31)<<std::endl;
    std::cout<<" tau1 Eta;"<<sizeTauAccept1->Integral(0,11)<<std::endl;
    std::cout<<" tau1 ID;"<<sizeTauID1->Integral(0,11)<<std::endl;
    std::cout<<" tau1 LC Isolation DB;"<<sizeTauISO1->Integral(0,11)<<std::endl;
    std::cout<<" Muon Tight;"<<sizeTau1AgMu->Integral(0,31)<<std::endl;
    std::cout<<" Electron Loose;"<<sizeTauAgainstLepton1->Integral(0,11)<<std::endl;
    // std::cout<<" tau1 Delta Z;"<<sizeTauDeltaZ1->Integral(0,11)<<std::endl;
    
    std::cout<<" DR(Mu,tau2);"<<sizeTau2DRMu->Integral(0,31)<<std::endl;
    
    std::cout<<" tau2 Pt;"<<sizeTauPt2->Integral(0,11)<<std::endl;
    std::cout<<" tau2 Eta;"<<sizeTauAccept2->Integral(0,11)<<std::endl;
    std::cout<<" tau2 ID;"<<sizeTauID2->Integral(0,11)<<std::endl;
    std::cout<<" tau2 CM Isoltion DB;"<<sizeTauISO2->Integral(0,11)<<std::endl;
    std::cout<<" Muon Tight ;"<<sizeTau2AgMu->Integral(0,10)<<std::endl;
    std::cout<<" Electron Medium ;"<<sizeTauAgainstLepton2->Integral(0,11)<<std::endl;
    // std::cout<<" tau2 Delta Z;"<<sizeTauDeltaZ2->Integral(0,11)<<std::endl;
    
    std::cout<<" Extra Muons Veto;"<<NoExtraMuon->Integral(0,10)<<std::endl;
    std::cout<<" Electrons Veto;"<<sizeZeroEle->Integral(0,10)<<std::endl;
    std::cout<<" BJet Veto;"<<sizeJetMatch->Integral(0,10)<<std::endl;
    
    
    std::cout<<" DR(tau1,tau2);"<<sizeTau2DRTau1->Integral(0,31)<<std::endl;
    std::cout<<" Dist ZVertex (Tau1,Tau2);"<< sizeTauZDist->Integral(0,10)<<std::endl;
    std::cout<<" Dist ZVertex (Tau1,Mu);"<< sizeMuTau1Z->Integral(0,10)<<std::endl;
    std::cout<<" Zeta(Mu,Tau_h) Veto;"<<ZCut->Integral(0,10)<<std::endl;
    //std::cout<<"TAU SUBLEAD pt MAX;"<<tagli_5->Integral(0,3)<<std::endl;
    std::cout<<" charge cut;"<<tagli[6]->Integral(0,3)<<std::endl;
    std::cout<<"MT(mu,met) ;"<<sizeMtmumet->Integral(0,10)<<std::endl;
    
    
} //parentesi del void

void VHAnalyser_Jan13::bookHistograms() {
    if (!bookedHistos) {
        // Open Output File
        std::string root_file = fileName;
        outputFile = new TFile(root_file.c_str(), "RECREATE");
        outputFile->cd();
        TH1::SetDefaultSumw2();
        
        mupt_gen= new TH1F(" mupt_gen"," mupt_gen" ,100, 0, 200);
        mass_MuMet= new TH1F("mass_MuMet","mass_MuMet" ,100, 0, 200);
        mass_MuTau1= new TH1F("mass_MuTau1","mass_MuTau1", 100, 0, 200);
        mass_TauTau_SS= new TH1F("mass_TauTau_SS","mass_TauTau_SS", 100, 0, 200);
        mass_MuMet_PU= new TH1F("mass_MuMet_PU","mass_MuMet_PU" ,100, 0, 200);
        mass_MuTau1_PU= new TH1F("mass_MuTau1_PU","mass_MuTau1_PU", 100, 0, 200);
        mass_TauTau_SS_PU= new TH1F("mass_TauTau_SS_PU","mass_TauTau_SS_PU", 100, 0, 200);
        MtMuMetVsMet_afterCharge= new TH2F("MtMuMetVsMet_afterCharge","MtMuMetVsMet_afterCharge", 200,0,200,200,0,200);
        MtMuMetVsMet_afterZ= new TH2F("MtMuMetVsMet_afterZ","MtMuMetVsMet_afterZ", 200,0,200,200,0,200);
        MtMuTauVSMET_afterCharge= new TH2F("MtMuTauVSMET_afterCharge","MtMuTauVSMET_afterCharge", 200,0,200,200,0,200);
        MtMuTauVSMET_afterZ= new TH2F("MtMuTauVSMET_afterZ","MtMuTauVSMET_afterZ", 200,0,200,200,0,200);
        cosTauLeadVSMtMuMet_afterCharge= new TH2F("cosTauLeadVSMtMuMet_afterCharge","cosTauLeadVSMtMuMet_afterCharge", 10,-1.1,1.1,200,0,200);
        cosTauSubVSMtMuMet_afterCharge= new TH2F("cosTauSubVSMtMuMet_afterCharge","cosTauSubVSMtMuMet_afterCharge", 10,-1.1,1.1,200,0,200);
        cosTauLeadVSMtMuMet_afterZ= new TH2F("cosTauLeadVSMtMuMet_afterZ","cosTauLeadVSMtMuMet_afterZ", 10,-1.1,1.1,200,0,200);
        cosTauSubVSMtMuMet_afterZ= new TH2F("cosTauSubVSMtMuMet_afterZ","cosTauSubVSMtMuMet_afterZ", 10,-1.1,1.1,200,0,200);
        
        cosTauLeadVSMet_afterCharge= new TH2F("cosTauLeadVSMet_afterCharge","cosTauLeadVSMet_afterCharge", 10,-1.1,1.1,200,0,200);
        cosTauSubVSMet_afterCharge= new TH2F("cosTauSubVSMet_afterCharge","cosTauSubVSMet_afterCharge", 10,-1.1,1.1,200,0,200);
        cosTauSubVSMet_afterZ=new TH2F("cosTauSubVSMet_afterZ","cosTauSubVSMet_afterZ", 10,-1.1,1.1,200,0,200);
        cosTauLeadVSMet_afterZ=new TH2F("cosTauLeadVSMet_afterZ","cosTauLeadVSMet_afterZ", 10,-1.1,1.1,200,0,200);
        
        hNPU = new TH1F("hNPU", "Number of PileUp", 36, -0.5, 35.5);
        hNPU_PU = new TH1F("hNPU_PU", "Number of PileUp ripesato", 36, -0.5, 35.5);
        hnVertex = new TH1F("hnVertex", "Number of Vertex", 36, -0.5, 35.5);
        hnVertex2 = new TH1F("hnVertex2", "Number of Vertex", 36, -0.5, 35.5);
        hnVertex_PU = new TH1F("hnVertex_PU", "Number of Vertex reweighted", 36, -0.5, 35.5);
        hnVertex_PU2 = new TH1F("hnVertex_PU2", "Number of Vertex reweighted", 36, -0.5, 35.5);
        hnVertex3 = new TH1F("hnVertex3", "Number of Vertex", 36, -0.5, 35.5);
        hnVertex_PU3 = new TH1F("hnVertex_PU3", "Number of Vertex reweighted", 36, -0.5, 35.5);
        hnMuon = new TH1F("nMuon","number of muon", 31, -0.5, 5);
        hnTau = new TH1F("nTau","number ef tau", 31, -0.5, 5);
        hnElectron = new TH1F("nElectron","number of ele", 31, -0.5, 10);
        hnMET_PU = new TH1F("nMET_PU","number of MET PU", 31, -0.5, 5);
        hnMET = new TH1F("nMET","number of MET", 31, -0.5, 5);
        hMET_PU = new TH1F("hMET_PU","histogram of MET PU", 50, 0, 150);
        hMET = new TH1F("hMET","histogram of MET", 50, 0, 150);
        hEtaMuon = new TH1F("EtaMuon","eta of muon", 50, -5, 5);
        hrelIso = new TH1F("RelIso","relIso of muon",10,-0.3,20);
        hPtMuon = new TH1F("PtMuon","pt of muon candidate", 200, 0, 200);
        sizeMuonPt = new TH1F("sizeMuonPt", "Number of Muon after Pt cut", 31, -0.5, 30.5);
        sizeMuon = new TH1F("sizeMuon", "Number of Muon after cuts", 31, -0.5, 30.5);
        sizeMuonISO = new TH1F("sizeMuonISO", "Number of Muon after ISO cuts", 31, -0.5, 30.5);
        sizeMuonID = new TH1F("sizeMuonID", "Number of Muon after ID cuts", 31, -0.5, 30.5);
        sizeMuonAccept = new TH1F("sizeMuonAccept", "Number of Muon after Accept cuts", 31, -0.5, 30.5);
        hPtEle = new TH1F("hPtEle","pt of ele candidate", 100, 0, 200);
        nEle_baseSelection = new TH1F("nEle_baseSelection","number of electrons after baseline selection", 10, 0., 10);
        nTau_baseSelection1 = new TH1F("nTau_baseSelection1","number of tau1 after baseline selection", 10, 0., 10);
        sizeTauISO1 = new TH1F("sizeTauISO1","number of tau1 after ISO selection", 10, -0.5, 10.5);
        sizeTauID1 = new TH1F("sizeTauID1","number of tau1 after ID selection", 10,-0.5, 10.5);
        sizeTauDeltaZ1 = new TH1F("sizeTauDeltaZ1","number of tau1 after delta z selection", 10,-0.5, 10.5);
        sizeTauAccept1 = new TH1F("sizeTauAccept1","number of tau1 after Accept selection", 10, 0., 10);
        sizeTauPt1 = new TH1F("sizeTauPt1","number of tau1 after pt selection", 10, 0., 10);
        sizeTauAgainstLepton1 = new TH1F("sizeTauAgainstLepton1","number of tau1 after AgainstLepton selection", 10, 0., 10);
        nTau_baseSelection2 = new TH1F("nTau_baseSelection2","number of tau2 after baseline selection", 10, 0., 10);
        sizeTauISO2 = new TH1F("sizeTauISO2","number of tau2 after ISO selection", 10, -0.5, 10.5);
        sizeTauID2 = new TH1F("sizeTauID2","number of tau2 after ID selection", 10,-0.5, 10.5);
        sizeTauDeltaZ2 = new TH1F("sizeTauDeltaZ2","number of tau2 after delta z selection", 10,-0.5, 10.5);
        sizeTauAccept2 = new TH1F("sizeTauAccept2","number of tau2 after Accept selection", 10, 0., 10);
        sizeTauPt2 = new TH1F("sizeTauPt2","number of tau2 after pt selection", 10, 0., 10);
        sizeTauAgainstLepton2 = new TH1F("sizeTauAgainstLepton2","number of tau2 after AgainstLepton selection", 10, 0., 10);
        hTau_jetEta = new TH1F ("hTau_jetEta","eta of jet tau candidate", 50, -5, 5);
        hTau_deltaZ1 = new TH1F ("hTau_deltaZ2","delta Z of tau vertex and primary vertex ", 11, -0.1, 1);
        hTau_deltaZ2 = new TH1F ("hTau_deltaZ1","delta Z of tau vertex and primary vertex ", 11, -0.1, 1);
        hMuonEtaReco = new TH1F("hMuonEtaReco ","eta of muon ", 50, -5, 5);
        hMuonPtReco = new TH1F("hMuonPtReco ","pt of muon ", 100, 0, 200);
        hPtJet = new TH1F("PtJet","pt of jets", 100, 0, 200);
        hJettrackCountingHighEffBTag = new TH1F("hJet_trackCountingHighEffBTag","Jet_trackCountingHighEffBTag", 65,0,13);
        hPtJet_baseSelection = new TH1F("PtJet_baseSelection","pt of jets after baseline selection", 100, 0, 200);
        nJet_baseSelection = new TH1F("nJet_baseSelection","number of jets after baseline selection", 10, 0., 10);
        sizeJetMatch = new TH1F("sizeJetsMatch", "Number of event that has at least two good jets", 31, -0.5, 30.5);
        hWH_Pt = new TH1F("hWH_Pt","pt of mu + tau1+ tau2", 100, 0, 200);
        hTau1Pt_ottimizzazione = new TH1F("hTau1Pt_ottimizzazione","pt tau1", 100, 0, 100);
        hTau2Pt_ottimizzazione = new TH1F("hTau2Pt_ottimizzazione","pt tau2", 100, 0, 100);
        sizeTauZDist= new TH1F("sizeTauZDist","sizeTauZDist", 10, 0., 10);
        VertexX = new TH1F("VertexX","VertexX", 500, 0.1, 0.5);
        VertexY= new TH1F("VertexY","VertexY", 500, 0.1, 0.5);
        VertexZ= new TH1F("VertexZ","VertexZ", 100, 0, 30);
        VertexXY= new TH2F("VertexXY","VertexXY", 500, 0.1, 0.5, 500, 0.1, 0.5);
        MuTauVSHPt= new TH2F("MuTauVSHPt","MuTauVSHPt", 200, 0, 200, 200, 0, 200);
        sizeZeroEle = new TH1F("sizeZeroEle","sizeZeroEle", 10, 0., 10);
        ZCut = new TH1F("ZCut","ZCut", 10, 0., 10);
        NoExtraMuon= new TH1F("NoExtraMuon","NoExtraMuon", 10, 0., 10);
        sizeMuTau1Z= new TH1F("sizeMuTau1Z","sizeMuTau1Z", 10, 0., 10);
        bdiscrAleternative= new TH1F("bdiscrAlternative","simpleSecondaryVertexHighEffBTag", 10, -5, 5);
        bdiscrAleternativeAfter= new TH1F("bdiscrAlternativeAfter","simpleSecondaryVertexHighEffBTag", 10, -5, 5);
        sizeMuonMatchStat= new TH1F("sizeMuonMatchStat","sizeMuonMatchStat", 10, 0., 10.);
        sizeTau1DR= new TH1F("sizeTau1DR","sizeTau1DR", 10,-0.5, 10.5);
        sizeTau1AgMu= new TH1F("sizeTau1AgMu","sizeTau1AgMu", 10,-0.5, 10.5);
        sizeTau2AgMu= new TH1F("sizeTau2AgMu","sizeTau2AgMu", 10,-0.5, 10.5);
        sizeMuonChambers= new TH1F("sizeMuonChambers","sizeMuonChambers", 10,-0.5, 10.5);
        sizeTau2DRTau1=new TH1F("sizeTau2DRTau1","sizeTau2DRTau1", 10,-0.5, 10.5);
        sizeTau2DRMu=new TH1F("sizeTau2DRMu","sizeTau2DRMu", 10,-0.5, 10.5);
        VertexSS=new TH1F("VertexSS","VertexSS", 10,-0.5, 10.5);
        ZeroMuSS=new TH1F("ZeroMuSS","ZeroMuSS", 10,-0.5, 10.5);
        zeroBJetSS=new TH1F("ZeroBJetSS","ZeroBJetSS", 10,-0.5, 10.5);
        ZeroEleSS=new TH1F("ZeroEleSS","ZeroEleSS", 10,-0.5, 10.5);
        AfterSS=new TH1F("AfterSS","AfterSS", 10,-0.5, 10.5);
        mass_TauTau_AfterSS_PU = new TH1F("mass_TauTau_AfterSS_PU","mass_TauTau_AfterSS_PU", 200, 0, 100);
        MuTau1_AfterTau1= new TH1F("MuTau1_AfterTau1"," MuTau1_AfterTau1", 200, 0, 100);
        MuMET_AfterTau1= new TH1F("MuMET_AfterTau1"," MuMET_AfterTau1", 200, 0, 100);
        Tau1Pt_AfterTau1= new TH1F("Tau1Pt_AfterTau1"," Tau1Pt_AfterTau1", 200, 0, 100);
        MuPt_AfterTau1= new TH1F("MuPt_AfterTau1"," MuPt_AfterTau1", 200, 0, 100);
        
        //////////////////////////////////////// H per conteggi /////////////////////////////////////////////
        H_tot = new TH1F("H_tot","H tot",3,0,3);
        W_tot = new TH1F("W_tot","W tot",3,0,3);
        Z_tot = new TH1F("Z_tot","Z tot",3,0,3);
        t_tot = new TH1F("t_tot","t tot",3,0,3);
        muonStatus1 = new TH1F("muonStatus1","muonStatus1",3,0,3);
        WplusMuon = new TH1F("WplusMuon","WplusMuon",3,0,3);
        muonW = new TH1F("muonW","",3,0,3);
        muonWstatus3 = new TH1F("muonWstatus3","",3,0,3);
        tautauEvent = new TH1F("tautauEvent","",3,0,3);
        controlloTauTau = new TH1F("controlloTauTau","",3,0,3);
        FHEvent= new TH1F("FHEvent","",3,0,3);
        GTFHEvent=new TH1F("GTFHEvent","",3,0,3);
        elejetEvent=new TH1F("elejetEvent","",3,0,3);
        GTelejetEvent=new TH1F("GTelejetEvent","",3,0,3);
        mujetEvent=new TH1F("mujetEvent","",3,0,3);
        GTmujetEvent=new TH1F("GTmujetEvent","",3,0,3);
        FLEvent=new TH1F("FLEvent","",3,0,3);
        GTFLEvent=new TH1F("GTFLEvent","",3,0,3);
        
        initial_entries=new TH1F("initial_entries","",3,0,3);;
        entries_after_vertex=new TH1F("entries_after_vertex","",3,0,3);;
        entries_after_vertex_PU=new TH1F("entries_after_vertex_PU","",3,0,3);;
        sizeAfterTrigger= new TH1F("sizeAfterTrigger", "sizeAfterTrigger", 3, 0, 3);
        sizeAfterTrigger_PU = new TH1F("sizeAfterTrigger_PU", "sizeAfterTrigger_PU", 3, 0, 3);
        
        MuonMatchEvent=new TH1F("MuonMatchEvent","",3,0,3);
        TauMatchEvent=new TH1F("TauMatchEvent","",3,0,3);
        JetMatchEvent=new TH1F("JetMatchEvent","",3,0,3);
        
        for(Int_t i=0; i<8; i++){
            char title[12];
            //itoa (i,title,10);
            sprintf(title,"tagli_%d",i);
            tagli[i] = new TH1F(title,"tagli",3,0,3);
            char title2[15];
            //itoa (i,title,10);
            sprintf(title2,"tagli_%d_PU",i);
            tagli_PU[i] = new TH1F(title2,"tagli_PU",3,0,3);
            
        }
        
        
        
        mass_Mu1Mu2= new TH1F("mass_Mu1Mu2","mass_Mu1Mu2", 100, 0, 200);
        mass_Mu1Tau1= new TH1F("mass_Mu1Tau1","mass_Mu1Tau1", 100, 0, 200);
        mass_Mu2Tau1= new TH1F("mass_Mu2Tau1","mass_Mu2Tau1", 100, 0, 200);
        mass_Mu1Tau2= new TH1F("mass_Mu1Tau2","mass_Mu1Tau2", 100, 0, 200);
        mass_Mu2Tau2= new TH1F("mass_Mu2Tau2","mass_Mu2Tau2", 100, 0, 200);
        
        mass_Mu1Mu2_jtotau1= new TH1F("mass_Mu1Mu2_jtotau1","mass_Mu1Mu2", 100, 0, 200);
        mass_Mu1Tau1_jtotau1= new TH1F("mass_Mu1Tau1_jtotau1","mass_Mu1Tau1", 100, 0, 200);
        mass_Mu2Tau1_jtotau1= new TH1F("mass_Mu2Tau1_jtotau1","mass_Mu2Tau1", 100, 0, 200);
        mass_Mu1Tau2_jtotau1= new TH1F("mass_Mu1Tau2_jtotau1","mass_Mu1Tau2", 100, 0, 200);
        mass_Mu2Tau2_jtotau1= new TH1F("mass_Mu2Tau2_jtotau1","mass_Mu2Tau2", 100, 0, 200);
        
        hTau1Eta_jtotau1 =new TH1F("hTau1Eta_jtotau1" ,"eta of tau ", 12, -3, 3);
        hTau1Pt_jtotau1 = new TH1F("hTau1Pt_jtotau1" ,"pt of tau ", 100, 0, 200);
        hTau2Eta_jtotau1 =new TH1F("hTau2Eta_jtotau1" ,"eta of tau ", 12, -3, 3);
        hTau2Pt_jtotau1 = new TH1F("hTau2Pt_jtotau1" ,"pt of tau ", 100, 0, 200);
        hMuon1Pt_jtotau1 = new TH1F("hMuon1Pt_jtotau1","pt of muon1 ", 100, 0, 200);
        hMuon1Eta_jtotau1 = new TH1F("hMuon1Eta_jtotau1" ,"eta of muon1 ", 12, -3, 3);
        hMuon2Pt_jtotau1 = new TH1F("hMuon2Pt_jtotau1" ,"pt of muon2 ", 100, 0, 200);
        hMuon2Eta_jtotau1 = new TH1F("hMuon2Eta_jtotau1" ,"eta of muon2 ", 12, -3, 3);
        massainv_TauTau_jtotau1 = new TH1F("massainv_TauTau_jtotau1","visible mass tau muon", 50, 0, 200);
        tagli_7_jtotau1 = new TH1F("tagli_7_jtotau1","tagli7",3,0,3);
        
        mass_Mu1Mu2_jtotau2= new TH1F("mass_Mu1Mu2_jtotau2","mass_Mu1Mu2", 100, 0, 200);
        mass_Mu1Tau1_jtotau2= new TH1F("mass_Mu1Tau1_jtotau2","mass_Mu1Tau1", 100, 0, 200);
        mass_Mu2Tau1_jtotau2= new TH1F("mass_Mu2Tau1_jtotau2","mass_Mu2Tau1", 100, 0, 200);
        mass_Mu1Tau2_jtotau2= new TH1F("mass_Mu1Tau2_jtotau2","mass_Mu1Tau2", 100, 0, 200);
        mass_Mu2Tau2_jtotau2= new TH1F("mass_Mu2Tau2_jtotau2","mass_Mu2Tau2", 100, 0, 200);
        hTau1Eta_jtotau2 =new TH1F("hTau1Eta_jtotau2" ,"eta of tau ", 12, -3, 3);
        hTau1Pt_jtotau2 = new TH1F("hTau1Pt_jtotau2" ,"pt of tau ", 100, 0, 200);
        hTau2Eta_jtotau2 =new TH1F("hTau2Eta_jtotau2" ,"eta of tau ", 12, -3, 3);
        hTau2Pt_jtotau2 = new TH1F("hTau2Pt_jtotau2" ,"pt of tau ", 100, 0, 200);
        hMuon1Pt_jtotau2 = new TH1F("hMuon1Pt_jtotau2","pt of muon1 ", 100, 0, 200);
        hMuon1Eta_jtotau2 = new TH1F("hMuon1Eta_jtotau2" ,"eta of muon1 ", 12, -3, 3);
        hMuon2Pt_jtotau2 = new TH1F("hMuon2Pt_jtotau2" ,"pt of muon2 ", 100, 0, 200);
        hMuon2Eta_jtotau2 = new TH1F("hMuon2Eta_jtotau2" ,"eta of muon2 ", 12, -3, 3);
        massainv_TauTau_jtotau2 = new TH1F("massainv_TauTau_jtotau2","visible mass tau muon", 50, 0, 200);
        tagli_7_jtotau2 = new TH1F("tagli_7_jtotau2","tagli7",3,0,3);
        
        mass_Mu1Mu2_DC= new TH1F("mass_Mu1Mu2_DC","mass_Mu1Mu2", 100, 0, 200);
        mass_Mu1Tau1_DC= new TH1F("mass_Mu1Tau1_DC","mass_Mu1Tau1", 100, 0, 200);
        mass_Mu2Tau1_DC= new TH1F("mass_Mu2Tau1_DC","mass_Mu2Tau1", 100, 0, 200);
        mass_Mu1Tau2_DC= new TH1F("mass_Mu1Tau2_DC","mass_Mu1Tau2", 100, 0, 200);
        mass_Mu2Tau2_DC= new TH1F("mass_Mu2Tau2_DC","mass_Mu2Tau2", 100, 0, 200);
        hTau1Eta_DC =new TH1F("hTau1Eta_DC" ,"eta of tau ", 12, -3, 3);
        hTau1Pt_DC = new TH1F("hTau1Pt_DC" ,"pt of tau ", 100, 0, 200);
        hTau2Eta_DC =new TH1F("hTau2Eta_DC" ,"eta of tau ", 12, -3, 3);
        hTau2Pt_DC = new TH1F("hTau2Pt_DC" ,"pt of tau ", 100, 0, 200);
        hMuon1Pt_DC = new TH1F("hMuon1Pt_DC","pt of muon1 ", 100, 0, 200);
        hMuon1Eta_DC = new TH1F("hMuon1Eta_DC" ,"eta of muon1 ", 12, -3, 3);
        hMuon2Pt_DC = new TH1F("hMuon2Pt_DC" ,"pt of muon2 ", 100, 0, 200);
        hMuon2Eta_DC = new TH1F("hMuon2Eta_DC" ,"eta of muon2 ", 12, -3, 3);
        massainv_TauTau_DC = new TH1F("massainv_TauTau_DC","visible mass tau muon", 50, 0, 200);
        tagli_7_DC = new TH1F("tagli_7_DC","tagli7",3,0,3);
        
        
        
        for(Int_t i=0; i<8; i++){
            char titleptTau1[25];
            char titleetaTau1[25];
            char titleptTau2[25];
            char titleetaTau2[25];
            char titleptMu1[25];
            char titleetaMu1[25];
            char titleptMu2[25];
            char titleetaMu2[25];
            char titleminv[25];
            char titledB_err[25];
            char titledB[25];
            sprintf(titleetaTau1,"hTau1Eta_taglio%d",i);
            sprintf(titleptTau1,"hTau1Pt_taglio%d",i);
            sprintf(titleetaTau2,"hTau2Eta_taglio%d",i);
            sprintf(titleptTau2,"hTau2Pt_taglio%d",i);
            sprintf(titleetaMu1,"hMuon1Eta_taglio%d",i);
            sprintf(titleptMu1,"hMuon1Pt_taglio%d",i);
            sprintf(titleetaMu2,"hMuon2Eta_taglio%d",i);
            sprintf(titleptMu2,"hMuon2Pt_taglio%d",i);
            sprintf(titleminv,"massainv_TauTau_taglio%d",i);
            sprintf(titledB_err,"dB_edB_taglio%d",i);
            sprintf(titledB,"MuondB_taglio%d",i);
            
            char titleptTau1_PU[25];
            char titleetaTau1_PU[25];
            char titleptTau2_PU[25];
            char titleetaTau2_PU[25];
            char titleptMu_PU[25];
            char titleetaMu_PU[25];
            char titleminv_PU[25];
            char titledB_err_PU[30];
            char titledB_PU[25];
            sprintf(titleetaTau1_PU,"hTau1Eta_taglio%d_PU",i);
            sprintf(titleptTau1_PU,"hTau1Pt_taglio%d_PU",i);
            sprintf(titleetaTau2_PU,"hTau2Eta_taglio%d_PU",i);
            sprintf(titleptTau2_PU,"hTau2Pt_taglio%d_PU",i);
            sprintf(titleetaMu_PU,"hMuonEta_taglio%d_PU",i);
            sprintf(titleptMu_PU,"hMuonPt_taglio%d_PU",i);
            sprintf(titleminv_PU,"massainv_TauTau_taglio%d_PU",i);
            sprintf(titledB_err_PU,"dB_edB_taglio%d_PU",i);
            sprintf(titledB_PU,"MuondB_taglio%d_PU",i);
            
            
            hTau1Eta[i]=new TH1F(titleetaTau1 ,"eta of tau ", 12, -3, 3);
            hTau1Pt[i]= new TH1F(titleptTau1 ,"pt of tau ", 100, 0, 200);
            hTau2Eta[i]=new TH1F(titleetaTau2 ,"eta of tau ", 12, -3, 3);
            hTau2Pt[i]= new TH1F(titleptTau2 ,"pt of tau ", 100, 0, 200);
            hMuon1Pt[i]= new TH1F(titleptMu1 ,"pt of muon1 ", 100, 0, 200);
            hMuon1Eta[i]= new TH1F(titleetaMu1 ,"eta of muon1 ", 12, -3, 3);
            hMuon2Pt[i]= new TH1F(titleptMu2 ,"pt of muon2 ", 100, 0, 200);
            hMuon2Eta[i]= new TH1F(titleetaMu2 ,"eta of muon2 ", 12, -3, 3);
            massainv_TauTau[i] = new TH1F(titleminv,"visible mass tau muon", 100, 0, 200);
            hdB_err[i]=new TH1F(titledB_err," dB/dB_err per mu",100,-3,10);
            muondB[i] = new TH1F(titledB,"db of muon ",100,-0.1,0.1);
            
            hTau1Eta_PU[i]=new TH1F(titleetaTau1_PU ,"eta of tau ", 12, -3, 3);
            hTau1Pt_PU[i]= new TH1F(titleptTau1_PU ,"pt of tau ", 100, 0, 200);
            hTau2Eta_PU[i]=new TH1F(titleetaTau2_PU ,"eta of tau ", 12, -3, 3);
            hTau2Pt_PU[i]= new TH1F(titleptTau2_PU ,"pt of tau ", 100, 0, 200);
            hMuonPt_PU[i]= new TH1F(titleptMu_PU ,"pt of muon ", 100, 0, 200);
            hMuonEta_PU[i]= new TH1F(titleetaMu_PU ,"eta of muon ", 12, -3, 3);
            massainv_TauTau_PU[i] = new TH1F(titleminv_PU,"visible mass tau muon", 100, 0, 200);
            hdB_err_PU[i]=new TH1F(titledB_err_PU," dB/dB_err per mu",100,-3,10);
            muondB_PU[i] = new TH1F(titledB_PU,"db of muon ",100,-0.1,0.1);
            
            
        }
        hmassa_trasversa = new TH1F("hmassa_trasversa", "massa trasversa",12,0,120);
        deltaPhi_muMET = new TH1F("deltaPhi_muMET","DeltaPhi tra mu e MET", 20, -1.5, 1.5);
        hPt_ratio = new TH1F("pt_ratio","ratio of pt",100,-0.1,1.1);
        hPt_ratio_PU = new TH1F("pt_ratio_PU","ratio of pt",100,-0.1,1.1);
        hPt_ratio_Final = new TH1F("pt_ratio_Final","ratio of pt",100,-0.1,1.1);
        hPt_ratio_Final_PU = new TH1F("pt_ratio_Final_PU","ratio of pt",100,-0.1,1.1);
        
        sizeMuonTrackGlob= new TH1F("sizeMuonTrackGlob", "sizeMuonTrackGlob", 31, -0.5, 30.5);
        sizeMuonPixHits= new TH1F("sizeMuonPixHits", "sizeMuonPixHits", 31, -0.5, 30.5);
        sizeMuonTrackHits= new TH1F("sizeMuonTrackHits", "sizeMuonTrackHits", 31, -0.5, 30.5);
        sizeMuonChi2= new TH1F("sizeMuonChi2", "Number of Muon after chi2", 31, -0.5, 30.5);
        sizeMuondB= new TH1F("sizeMuondB", "Number of Muon after dB cuts", 31, -0.5, 30.5);
        sizeMuonDistZ= new TH1F("sizeMuonDistZ", "Number of Muon after distZ cuts", 31, -0.5, 30.5);
        sizeMuonNMatch= new TH1F("sizeMuonNMatch", "Number of Muon after NMatch", 31, -0.5, 30.5);
        sizeMtmumet= new TH1F("sizeMtmumet", "sizeMtmumet", 31, -0.5, 30.5);
        ////////////////////////////
    }
}


void VHAnalyser_Jan13::saveHistograms() {
    if (outputFile) {
        f_puweights->Close();
        std::string root_file = fileName;
        outputFile = new TFile(root_file.c_str(), "RECREATE");
        outputFile->cd();
        
        
        hNPU->Write();
        hNPU_PU->Write();
        hnVertex->Write();
        hnVertex2->Write();
        hnVertex_PU->Write();
        hnVertex_PU2->Write();
        hnElectron->Write();
        hnTau->Write();
        hnMuon->Write();
        hnMET->Write();
        hnMET_PU->Write();
        hMET->Write();
        hMET_PU->Write();
        hPtMuon->Write();
        hEtaMuon->Write();
        hrelIso->Write();
        sizeMuon->Write();
        sizeMuonAccept->Write();
        sizeMuonISO->Write();
        sizeMuonTrackGlob->Write();
        sizeMuonPixHits->Write();
        sizeMuonTrackHits->Write();
        sizeMuonChi2->Write();
        sizeMuondB->Write();
        sizeMuonDistZ->Write();
        sizeMuonNMatch->Write();
        sizeMuonChambers->Write();
        sizeMuonID->Write();
        sizeMuonMatchStat->Write();
        sizeTau1DR->Write();
        sizeTauAgainstLepton1->Write();
        sizeTauISO1->Write();
        sizeTau1AgMu->Write();
        sizeTauDeltaZ1->Write();
        sizeTauID1->Write();
        sizeTauAccept1->Write();
        sizeTauPt1->Write();
        sizeTauAgainstLepton2->Write();
        sizeTauISO2->Write();
        sizeTauDeltaZ2->Write();
        sizeTauID2->Write();
        sizeTauAccept2->Write();
        sizeTauPt2->Write();
        sizeTau2DRTau1->Write();
        sizeTau2DRMu->Write();
        sizeTau2AgMu->Write();
        hMuonPtReco->Write();
        hMuonEtaReco->Write();
        hPtEle->Write();
        nEle_baseSelection->Write();
        nTau_baseSelection1->Write();
        nTau_baseSelection2->Write();
        hTau_jetEta->Write();
        hTau_deltaZ1->Write();
        hTau_deltaZ2->Write();
        
        hWH_Pt->Write();
	    
        MuTauVSHPt->Write();
        H_tot->Write();
        W_tot->Write();
        Z_tot->Write();
        t_tot->Write();
        muonStatus1->Write();
        WplusMuon->Write();
        muonW->Write();
        muonWstatus3->Write();
        tautauEvent->Write();
        controlloTauTau->Write();
        FHEvent->Write();
        GTFHEvent->Write();
        elejetEvent->Write();
        GTelejetEvent->Write();
        mujetEvent->Write();
        GTmujetEvent->Write();
        FLEvent->Write();
        GTFLEvent->Write();
        initial_entries->Write();
        entries_after_vertex->Write();
        entries_after_vertex_PU->Write();
        sizeAfterTrigger->Write();
        sizeAfterTrigger_PU->Write();
        
        sizeMuonPt->Write();
        
        
        
        sizeTauZDist->Write();
        sizeMuTau1Z->Write();
        sizeZeroEle->Write();
        sizeJetMatch->Write();
        ZCut->Write();
        NoExtraMuon->Write();
        
        mass_MuMet->Write();
        mass_MuTau1->Write();
        mass_TauTau_SS->Write();
        mass_MuMet_PU->Write();
        mass_MuTau1_PU->Write();
        mass_TauTau_SS_PU->Write();
        
        
        MuTau1_AfterTau1->Write();
        MuMET_AfterTau1->Write();
        Tau1Pt_AfterTau1->Write();
        MuPt_AfterTau1->Write();
        
        
        hTau1Pt[7]->Write();
        hTau1Eta[7]->Write();
        hTau2Pt[7]->Write();
        hTau2Eta[7]->Write();
        hMuon1Pt[7]->Write();
        hMuon2Pt[7]->Write();
        hMuon1Eta[7]->Write();
        hMuon2Eta[7]->Write();
        massainv_TauTau[7]->Write();
        mass_Mu1Mu2->Write();
        mass_Mu1Tau1->Write();
        mass_Mu2Tau1->Write();
        mass_Mu1Tau2->Write();
        mass_Mu2Tau2->Write();
        
        tagli[7]->Write();
        tagli[6]->Write();
        tagli[4]->Write();
        tagli[0]->Write();
        
        MtMuMetVsMet_afterCharge->Write();
        
        
        MtMuMetVsMet_afterZ->Write();
        MtMuTauVSMET_afterCharge->Write();
        MtMuTauVSMET_afterZ->Write();
        cosTauLeadVSMtMuMet_afterCharge->Write();
        cosTauSubVSMtMuMet_afterCharge->Write();
        cosTauLeadVSMtMuMet_afterZ->Write();
        cosTauSubVSMtMuMet_afterZ->Write();
        
        cosTauLeadVSMet_afterCharge->Write();
        cosTauSubVSMet_afterCharge->Write();
        cosTauSubVSMet_afterZ->Write();
        cosTauLeadVSMet_afterZ->Write();
        mupt_gen->Write();
        sizeMtmumet->Write();
        
        //delete outputFile;
    }
}
